"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from pydantic import model_serializer
from shippo.types import BaseModel, UNSET_SENTINEL
from typing import Optional
from typing_extensions import NotRequired, TypedDict


class CustomerReferenceTypedDict(TypedDict):
    r"""Specify the reference field on the label (FedEx and UPS only)."""

    prefix: NotRequired[str]
    r"""Custom prefix for customer reference field (ZPL labels only). Up to 11 characters, including trailing
    spaces. Empty string indicates removal of default prefix. To use the default prefix, do not include
    this property.
    """
    value: NotRequired[str]
    r"""Optional text to be printed on the shipping label for customer reference. Up to 40 characters. If
    this is provided, reference_1 will be ignored.
    """
    ref_sort: NotRequired[int]
    r"""Order UPS reference fields are printed on ZPL labels. For UPS shipments, if you choose to set `ref_sort` for one reference, you must set `ref_sort` for all other supported UPS references using unique integers."""


class CustomerReference(BaseModel):
    r"""Specify the reference field on the label (FedEx and UPS only)."""

    prefix: Optional[str] = None
    r"""Custom prefix for customer reference field (ZPL labels only). Up to 11 characters, including trailing
    spaces. Empty string indicates removal of default prefix. To use the default prefix, do not include
    this property.
    """

    value: Optional[str] = None
    r"""Optional text to be printed on the shipping label for customer reference. Up to 40 characters. If
    this is provided, reference_1 will be ignored.
    """

    ref_sort: Optional[int] = None
    r"""Order UPS reference fields are printed on ZPL labels. For UPS shipments, if you choose to set `ref_sort` for one reference, you must set `ref_sort` for all other supported UPS references using unique integers."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["prefix", "value", "ref_sort"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
